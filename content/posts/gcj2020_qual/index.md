---
title: Qualification Round 2020 - Code Jam 2020 参加記
date: 2020-04-08
categories:
  - 競プロ
tags:
  - GCJ
---

# 問題情報
https://codingcompetitions.withgoogle.com/codejam/round/000000000019fd27

問題文の要約と参加メモ。ちなみに、BとCのVisibleをすべて解けば予選は突破できる。

# A: Vestigium

## 問題概要
$N$ 次の正方行列が与えられる。以下を出力せよ
- 対角成分の和
- 同じ値が2個以上含まれる行の数
- 同じ値が2個以上含まれる列の数

制約
- テストケース数: 100以下
- $2 \leq N \leq 100$

## 観察
制約より、定義に通り計算すれば間に合う。

## 考察
やるだけ

## 実装
同じ値が2個以上含まれる行／列の数は、各行／列をsetに変換し、サイズが $N$ に等しいか判定すると楽。

## 教訓
GCJの出力は難しい。

# B: Nesting Depth

## 問題概要
数字から成る文字列 $S$ が与えられる。以下の条件を満たすように $S$ に括弧を付与する。

条件: 各数字はその数字の個数に等しい括弧に括られている。

付与する括弧の個数を最小化するとき、付与後の文字列を出力せよ。

例: $S = \rm{021\}$ のとき、 `0((2)1)` を出力する。
`0((2))(1)` も条件を満たすが、括弧の個数が最小でないのでNG.

制約
- テストケース数: 100以下
- $1 \leq |S| \leq 100$

## 観察
$S = \rm{021\}$ の場合を考える。0の前に括弧は置けない。2の前に開き括弧を2個置く必要がある。
1の前に閉じ括弧を1個置く必要がある。ここまでは勝手に確定する。

1の前に閉じ括弧をもう1個置くことは可能である。
閉じ括弧をもう1個置く場合は開き括弧も置く必要がある。
例より、閉じ括弧は2個置かないほうが括弧の個数を減らせる。

## 考察
観察より、数字の後に閉じ括弧をどれだけ置くかを考える必要がある。
つまり、閉じられていない括弧の個数を直後の数字より小さくする意味があるかを考えればよい。
閉じ括弧を余分に置いた場合、閉じ括弧の後にその分だけ開き括弧が必要になる。
結局、閉じられていない括弧の個数は変わらないのに、使用している括弧の個数は増える。
以上より、閉じられていない括弧の個数を直後の数字より小さくする意味はない。

## 実装
$S$ を先頭から走査し、閉じられていない括弧の個数を記憶しながら、必要な分だけ括弧を開き、必要な分だけ括弧を閉じていけばよい。

## 教訓
具体例で考えるとすぐに解法が見えた。

# C: Parenting Partnering Returns

## 問題概要
$N$ 個の区間 $[S_i, T_i)$ が与えられる。2種類のラベル `C`, `J` がある。
以下の条件を満たすように各区間にラベルを1つ付与する。

条件: 同じラベルが付与されている区間はオーバーラップしない

条件を満たす付与方法があるならば付与方法を一つ出力せよ（複数ある場合は何でもよい）。
条件を満たす付与方法がないならばIMPOSSIBLEと出力せよ

制約:
- テストケース数: 100以下
- $0 \leq S_i < E_i \leq 24 \times 60$
- $2 <= N <= 1000$

## 観察
サンプル1（区間 $[360, 480), [420, 540), [600, 660)$ が与えられる場合）を考える。
1個目の区間 $[360, 480)$ に `C` を付与して一般性を失わない。
2個目の区間 $[420, 540)$ は1個目の区間とオーバーラップするので `C` を付与できない。
よって、`J` を付与するしかない。
3個目の区間 $[600, 660)$ はどちらの区間ともオーバーラップしないので、適当に `C` を付与する。

サンプル2（区間 $[0, 1440), [1, 3), [2, 4)$ が与えられる場合）を考える。
1個目の区間 $[0, 1440)$ に `C` を付与して一般性を失わない。
2個目の区間 $[1, 3)$ は1個目の区間とオーバーラップするので `C` を付与できない。
よって、`J` を付与するしかない。
3個目の区間 $[2, 4)$ はどちらの区間ともオーバーラップする。
1個目の区間には `C`, 2個目の区間には `J` が付与されているので、詰んでいる。

## 考察
観察より、先頭の区間から順に付与可能なラベルを付与すればよさそうである。
`C`, `J` どちらも付与可能な場合、どちらでもよいのは明らかである。
よって、付与可能なラベルを適当に付与し続ければよい。

## 実装
観察で挙げた例は始点により区間がソートされていたが、サンプル3のようにソートされてないケースもあることに注意。
始点についてソートしておけば、区間を先頭から順に走査し、各ラベルの終点を更新するだけでオーバーラップを判定できるので楽。

## 教訓
反例がないか少し不安になるけど、やれることが少ないので安心できる。

# D: ESAb ATAd

## 問題概要
長さ $B$ のビット列がある。各ビットの初期状態は不明である。
あなたは指定したビットの現状態を取得するクエリを送信できる。
ただし、クエリを10回送信するたびに各ビットの状態は以下のうち、いずれかの変化をする（それぞれ確率 $1/4$ で選ばれる）。
- 各ビットが反転する
- ビット列の順序が反転する
- 各ビットが反転し、ビット列の順序も反転する
- 変化なし

クエリを150回まで送信し、 ビット列の現状態を当てよ。

制約:
- テストケース数: 100以下
- $B \in \\{10, 20, 100\\}$

## 観察
このままだと難しいので、問題を簡単にしてみる。

### 常に変化なしの場合
$B$ 回クエリを送信するだけである（つまり、高々100回で当てられる）。

### 常に各ビットが反転する場合
クエリを10回送信するたびに、記憶しているビットを反転すればよい。
したがって、$B$ 回クエリを送信すれば当てられる。

### 常にビット列の順序が反転する場合
クエリを10回送信するたびに、記憶しているビット列の順序を反転すればよい。
したがって、$B$ 回クエリを送信すれば当てられる。

### 常に各ビット・ビット列の順序が反転する場合
クエリを10回送信するたびに、記憶しているビットとビット列の順序を反転すればよい。
したがって、$B$ 回クエリを送信すれば当てられる。

### 各ビットが反転する or 変化なしの場合
この場合、クエリを10回送信するたびにどの変化が発生したかを確かめないと現状態が追跡できない。
クエリを10回送信したら、記憶しているビットを一つ選び、そのビットについて再びクエリを送信する。
記憶している値と異なればビット反転していることが分かるので、記憶しているすべてのビットを反転すればよい。
記憶している値と同じならば変化なしであることが分かるので、記憶しているビットをいじる必要なし。

11回クエリを送信するごとに10個のビットの状態を新たに追跡できるので、 クエリの送信回数は $1.1B$ 回に抑えられる
（つまり、高々110回で当てられる）。

### ビット列の順序が反転する or 変化なしの場合
この場合もクエリを10回送信するたびにどの変化が発生したかを確かめないと現状態が追跡できない。
クエリを10回送信したら、記憶しているビットを一つ選び、そのビットについて再びクエリを送信する。
ただし、反転しているか判定するため、選んだビットと反転先のビットの値が異なるビットを選ぶ必要がある。
記憶している値と異なればビット列の順序が反転していることが分かるので、記憶しているビット列の順序を反転すればよい。
記憶している値と同じならば変化なしであることが分かるので、記憶しているビットをいじる必要なし。

### 各ビット・ビット列の順序が反転する or 変化なしの場合
この場合もクエリを10回送信するたびにどの変化が発生したかを確かめないと現状態が追跡できない。
クエリを10回送信したら、記憶しているビットを一つ選び、そのビットについて再びクエリを送信する。
ただし、反転しているか判定するため、選んだビットと反転先のビットの値が等しいビットを選ぶ必要がある
記憶している値と異なれば各ビット・ビット列の順序が反転していることが分かるので、記憶しているビットとビット列の順序を反転すればよい。
記憶している値と同じならば変化なしであることが分かるので、記憶しているビットをいじる必要なし。

## 考察
起こり得る変化が2種類ならばそれほど難しくない。
続いて、3種類、4種類の場合も考察する。

### 各ビットが反転する or ビット列の順序が反転する or 変化なしの場合
やはりクエリを10回送信するたびにどの変化が発生したかを確かめないと現状態が追跡できない。
確かめる際、各変化を切り分ける必要がある。
1ビットだと2通りしか表現できないので、切り分けに2ビット必要なのは明らかである。
順序反転先のビットと等しい値のビット $i$ と 異なる値のビット $j$ を選ぶ。
$i$ に対するクエリの結果が記憶している値と異なる場合、各ビットの反転だと判断できる。
$i$ に対するクエリの結果が記憶している値と同じ場合、ビット列の順序反転 or 変化なしである。
これを切り分けるため、 $j$ に対してもクエリを送信する。
$j$ に対するクエリの結果が記憶している値と異なる場合、ビット順序の反転だと判断できる。
$j$ に対するクエリの結果が記憶している値と同じ場合、変化なしと判断できる。

上記の方法だと12回クエリを送信するごとに10個のビットの状態を新たに追跡できるので、クエリの送信回数は $1.2B$ 回に抑えられる
（つまり、高々120回で当てられる）。

### 元の問題
起こり得る変化が3種類の場合とほぼ同様である。
切り分けに2ビット用いる。
順序反転先のビットと等しい値のビット $i$ と 異なる値のビット $j$ を選ぶ。

$i$ に対するクエリの結果が記憶している値と異なる場合、各ビットの反転 or 各ビット・ビット列反転である。
これを切り分けるため、 $j$ に対してもクエリを送信する。
$j$ に対するクエリの結果が記憶している値と異なる場合、各ビットの反転だと判断できる。
$j$ に対するクエリの結果が記憶している値と同じ場合、各ビット・ビット列反転だと判断できる。

$i$ に対するクエリの結果が記憶している値と同じ場合、ビット列の順序反転 or 変化なしである。
これを切り分けるため、 $j$ に対してもクエリを送信する。
$j$ に対するクエリの結果が記憶している値と異なる場合、ビット順序の反転だと判断できる。
$j$ に対するクエリの結果が記憶している値と同じ場合、変化なしと判断できる。

上記の方法も12回クエリを送信するごとに10個のビットの状態を新たに追跡できるので、クエリの送信回数は $1.2B$ 回に抑えられる
（つまり、高々120回で当てられる）。

## 実装
記憶しているビットの状態は愚直に管理しても間に合う。
順序反転先のビットと等しい値のビット・異なる値のビットを探すため、両端から順にクエリを送信するとよい。
順序反転先と等しい変化なしと判断できる。／異なるビットが連なる場合は、変化の切り分けができないが、切り分ける必要もない。
例えば、順序反転先と等しいビットが連なっている場合は、「変化なし」と「ビット順序反転」を切り分ける必要がない。

## 教訓
- いきなり難しい問題から考えるのではなく、自分で簡単な問題を作って解いてみると活路が見えてきた
- 序反転先のビットと等しい値のビットが連なる場合のような、変化の切り分けを完全にできないケースが難しいと感じたが、そのような場合、そもそも切り分ける必要があるのかを考え直す習慣をつけたほうがよさそう
